client : for frontend ( web Application) 
server: for backend (node API)

# web Application -> http request -> Node API

# we are using Express : most used pattern in express is MVC

# MVC 
 USER ->use -> CONTROLLER -> manipulates -> MODEL -> updates -> VIEW -> see -> USER 

# Folders inside server
1. models : for MVC
2. Routes : for different routers
   inside it : controllers : defines how we response to that specific route

# Folders in root 
1. client 
2. server

# It is a good practise to separate packages for both client and server
client => own package.json
server => own package.json
root => one package.json at the root level as well  

# always create package.json by : npm init 

# we are given the frontend with package json
1. now we need to install the dependencies : 1. cd client 
                                             2. npm install 
                                             3. npm start

# So we are having our API request to be embedded into request.js under hooks 

# setting up npm package in server side 
1. cd server 
2. npm init -y
2. npm install express

# Installing nodemon : helps preventing restaring the code again and again 
1. npm i nodemon
2. in package json under script =>   "watch": "nodemon src/server.js",
                                     "start": "node src/server.js"


# Try to follow similar pattern as of client 
1. so put src folder in server
2. move all js code in it 
3. also move models. routes into src

NOTE ; make  .gitignore and place /node_modules inside it 

# working on server.js
we can run client and server side on different ports
here client => 3001 and server => 8000

const PORT = process.env.PORT || 8000
if port already exist in the environment and is running then run on it else use port 8000

# setting up express in server.js
1. const express = require('express')
2. const app = express()
3. app.listen()

# creating http 
1. const http = require('http')
2. const server = http.createServer(app)
3. server.listen(PORT, ()=>{
    console.log(`listening on port ${PORT}`)
   }) 

NOTE: http.createServer(app)
we passed 'app' here from our express as any middleware and route handlers attached to app will respond to request coming tp our server 

request -> http -> app => respond using middleware and route handlers 

express is just fancy listner function our build in node http server 

# app.js
=> has express code : helps separating our server functionality from sever in server.js
move all express code here 
1. const express = require('express')
2. const app = express()
3. modules.exports ={app}
server.js : const app = require('./app')


# Returning planets from our API
1. making router using express 
const express = require('express')
const planetRouter = express.Router()

const getAllPlanets = require('./planets.controller')

@ we need to get all planets 
planetRouter.get('/planets', getAllPlanets).   // getAllPlanets : this function will come from controllers

@ we need to export 
module.exports = {planetRouter}

@ In planets.controller.js
function getAllPlanets(req, res){
  return res.status(200).json(planets).   // so planets is the data that we are accesisng so we have our files in models 
}
module.exports = {getAllPlanets}

@ IN planets.model.js
const planets = []
module.exports = {planets}

@ In apps.js 
const planetsRouter = require('./routes/planets/planets.router')
app.use(planetsRouter)


NOTE : Routers makes direct use of conrollers so better place these files together

MODEL -> planets -> CONTROLLER -> getAllPlanets -> ROUTER -> planetRouter


# Fetching. it on client side 

@ IN request.js
under getAllPlanets
fetch(port of the server)

async function httpGetPlanets() {
  const response = await fetch('http://localhost:8000/planets')
  return await response.json()
}




NOTE: fetch return a promise so use await under asyn function 
       json() also returns a promise so use await under asyn function  


# As soon as we start client there is CORES error

CORE = cross origin request 
=> request made on one origin to a different origin 

origin = protocol + host + port
example http://www.google.com:443/maps/
protocol = http://
host = www.google.com
port = 443 

=> as a security feature same origin and send request to server of that origin not the different ones
ex. google and send request to google server not the facebook server

=> For cross origin request : Acess-Control-Allow-Origin: http:/www.google.com

=> installing CORS 
1. npm install cors

@ IN app.js
1. const cors = require('cors')
2. app.use(cors({origin: 'http://localhost:3000'}))


NOTE: 
1. for each router we have one unique controller
2. for each controller we might have one or many models
3. for each model we might have one for many controllers 

# Inside planet.model.js we have changed it to 
fs.createReadStream('kepler_data.csv')
  .pipe(parse({
    comment: '#',
    columns: true,
  }))
  .on('data', (data) => {
    if (isHabitablePlanet(data)) {
      habitablePlanets.push(data);
    }
  })


# .parse => goes line by line for csv data and converts into javascript objects
# .on => helps for checking certain conditions on javascript object created by parse 

# we need to install csv-parse lib : npm install csv-parse ( inside server )

NOTE : 
CLIENT -> send request -> CONTROLLER -> send request -> MODEL -> before the data even loads the exports function returns it, and we might get an empty list 

FIX for the above problem 

1. creating js promise for the data loading
2. wait until the data loads before we accept any incoming request 


# Promise
1. const promise = new Promise();
2. promise.then((result)=>{})

example: 
const promise = new Promise((resolve,reject)=> { resolve(42) });
1. promise.then((42)=>{})
2. const result = await promise     // await until the promise resolves 
  

# Fixing the issue by making sure that we have our list of habitable planets before the request from an API


1. putting all data processing inside a function 


function loadPlanetsData(){


function isHabitablePlanet(planet) {
  return planet['koi_disposition'] === 'CONFIRMED'
    && planet['koi_insol'] > 0.36 && planet['koi_insol'] < 1.11
    && planet['koi_prad'] < 1.6;
}
fs.createReadStream('kepler_data.csv')
  .pipe(parse({
    comment: '#',
    columns: true,
  }))
  .on('data', (data) => {
    if (isHabitablePlanet(data)) {
      habitablePlanets.push(data);
    }
  })
  .on('error', (err) => {
    console.log(err);
  })
  .on('end', () => {
    console.log(habitablePlanets.map((planet) => {
      return planet['kepler_name'];
    }));
    console.log(`${habitablePlanets.length} habitable planets found!`);
  });


}



2. we return a promise which resolves when our habitable Planets are found 
   and we wait for that promise to resolve before listening to any additional request 


function loadPlanetsData(){

return new Promise((resolve, reject)=> { 

function isHabitablePlanet(planet) {
  return planet['koi_disposition'] === 'CONFIRMED'
    && planet['koi_insol'] > 0.36 && planet['koi_insol'] < 1.11
    && planet['koi_prad'] < 1.6;
}
fs.createReadStream('kepler_data.csv')
  .pipe(parse({
    comment: '#',
    columns: true,
  }))
  .on('data', (data) => {
    if (isHabitablePlanet(data)) {
      habitablePlanets.push(data);
    }
  })
  .on('error', (err) => {
    console.log(err);
    reject(error)                                                          // rejecting if we receive any error
  })
  .on('end', () => {
    console.log(`${habitablePlanets.length} habitable planets found!`);
    resolve();                                                              // calling it when we are done parsing the data
  });


})
}


3. also exporting our loadPlanetsData 

module.exports = {loadPlanetData, planets: habitablePlanets}


4. go to server.js to setup await request 

const {loadPlanetData} = require('./models/planets.model')

async function startServer(app){
await loadPlanetData();
server.listen(PORT, ()=>{
    console.log(`listening on port ${PORT}`)
})
}

startServer();

4. also add path module 
1. const path = require('path')
2. fs.createReadStream(path.join(__dirname, '..', '..','data','kepler_data.csv'))
